<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML><HEAD><TITLE>Директивы</TITLE>
<link rel="stylesheet" type="text/css" href="../../style/style.css">
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
</HEAD>
<BODY topMargin=0 >
<TABLE
style="BORDER-RIGHT: medium none; BORDER-TOP: medium none; BORDER-LEFT: medium none; BORDER-BOTTOM: #c0c0c0 1px solid"
height=121 cellSpacing=0 cellPadding=0 width=640>
  <TBODY>
  <TR>
    <TD vAlign=top width="100%"><IMG
      src="img/ru/logo2.jpg" width="640" height="121" border=0 class="conthdr" ></TD>
</TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width=640 border=0>
  <TBODY>

  <TD width="100%" height="100%" vAlign=top>
   <DIV><IMG
      src="img/ru/old/coding/articles.png" width="640" height="33"></DIV>


      <TABLE cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD width=5><IMG height=36
            src="img/ru/mtdl.png" width=5></TD>
          <TD class=ntitle vAlign=top
          background="mtdbg.png" height=36>Директивы</TD>
          <TD width=5><IMG height=36
            src="img/ru/mtdr.png"
      width=20></TD></TR></TBODY></TABLE>
      <TABLE cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD width=5 background="ltd.gif"></TD>
          <TD class=news vAlign=top>
<p>
      Препроцессорные директивы - это специальные слова, которые указывают
компилятору на необходимое поведение в процессе компиляции.
Они обозначаются символом $, а также заключены в фигурные скобки {}.

<p>	Список доступных директив:
<ol>
	<li> <a href="#VERSION">$VERSION</a>
	<li> <a href="#RESTORE_VERSION">$VERSION_RESTORE</a>
	<li> <a href="#INCLUDE">$INCLUDE</a>
	<li> <a href="#EXTERNAL">$EXTERNAL</a>
	<li> <a href="#CLEO">$CLEO</a>
	<li> <a href="#NOSOURCE">$NOSOURCE</a>
	<li> <a href="#OPCODE">$OPCODE</a>
</ol>
<hr><br>
<p><a name="VERSION"><b>$VERSION</b></a>
<p><b>Эта директива устарела, начиная с версии 3.1.0</b>
<p>Данная директива указывает компилятору, какую версию опкодов
необходимо использовать из INI-файла (SASCM.INI, VICESCM.INI и т.д.).
В настоящий момент INI-файлы содержат только одну версию опкодов,
поэтому данная директива может не использоваться.
Синтаксис:<p>
 <DIV class=mycode5>	$VERSION x.y.zzzz<p>
	x - код игры. <br>
&nbsp;&nbsp;&nbsp;1 - gta3; <br>
&nbsp;&nbsp;&nbsp;2 - vc; <br>
&nbsp;&nbsp;&nbsp;3 - sa;<br>
&nbsp;&nbsp;&nbsp;4 - lcs;<br>
&nbsp;&nbsp;&nbsp;5 - vcs;<p>
		y - вид порядка следования параметров в опкоде.<br>
&nbsp;&nbsp;&nbsp;0 - оригинальный (параметры в INI идут последовательно 0, 1, 2 и т.д.)<br>
&nbsp;&nbsp;&nbsp;1 - неоригинальный (параметры в INI идут непоследовательно 2, 0, 1,  и т.д.)<p>
	zzzz - код версии файла</div>
 <br>

<p>
По умолчанию компилятор использует версию:
<div class="mycode5"> &lt;текущий режим редактирования&gt;.1.0000</div>
<hr><br><p><a name="RESTORE_VERSION"><b>$VERSION_RESTORE</b></A>
<p><b>Эта директива устарела, начиная с версии 3.1.0</b>
<p>Данная директива восстанавливает прежнюю версию, которая
была до использования директивы $VERSION.
В настоящий момент INI-файлы содержат только одну версию опкодов,
поэтому данная директива может не использоваться.
<p>
      Основная идея состоит в том, чтобы позволить одновременно компилировать
куски кода, написанные на разных версиях опкодов, путем заключения
их в данные директивы.
<DIV class=mycode5>
	<span class="general1-directive">{$VERSION 3.1.0001}</span><br>
	<br>

	...	&lt;код, написанный на версии 0001&gt;	....<p>

	<span class="general1-directive">{$VERSION 3.1.0000}</span><br>
	...	&lt;код, написанный на версии 0000&gt;	....<br>
	<span class="general1-directive">{$VERSION_RESTORE}</span> <span class="general1-comment">// восстанавливаем версию 0001</span><p>

	...	&lt;код, написанный на версии 0001&gt;	....</div>
<hr><br><p><a name="INCLUDE"><b>$INCLUDE</b></A>
<p>Эта директива позволяет подключать внешние текстовые файлы к исходнику. Когда компилятор находит указанную директиву, он открывает файл по адресу, переданному в качестве параметра директивы и продолжает компиляцию того кода, который записан во внешнем файле. Когда компилятор достигает конца данного файла, он возвращается обратно в предыдущий файл.
<p>Синтаксис:

<div class="mycode5"><span class="general1-directive">{$INCLUDE file_path}</span></div>
<p>или
<div class="mycode5"><span class="general1-directive">{$I file_path}</span></div>
<p>Например,
<div class="mycode5"><span class="general1-directive">{$I loadwav.txt}</span></div>
<p>или
<div class="mycode5"><span class="general1-directive">{$I C:\dev\getarrayindex.txt}</span></div>
<p><a name="rules"></a>Если в имени файла указан относительный путь, компилятор ищет файлы в следующем порядке:<br>
<br>
1. папка, где находится файл, содержащий данную директиву*<br>
2. Sanny Builder\data\&lt;game&gt;<br>
3. корневая папка Sanny Builder<br>
4. корневая папка игры
<p>Если ни в одной из указанных папок не содержится такой файл, компилятор сообщит об ошибке.
<p>Вы можете использовать данную директиву неограниченное число раз. Вкладываемые файлы могут также содержать в себе данную директиву.

<p>*Начиная с версии v3.1.1 это стало строгим правилом. Все пути, которые указаны в директиве $INCLUDE, явлются относительными по отношению к текущему обрабатываемому файлу.

<hr><br><a name="EXTERNAL"><b>$EXTERNAL</b></a>
<p>Данная директива заставляет скомпилировать файл как <a href="articles30.htm">внешний скрипт</a>. Это означает, что получившийся файл будет без  заголовка и с локальными метками, т.е. полным аналогом scm-файлов из файла script.img. Использование данной директивы подразумевает, что в скрипте будет только один поток (также без миссий и внешних скриптов).<br>
  Аналогом использования данной директивы является опция <a href="console.htm#SKIP_SCM">SKIP_SCM_HEADER</a>. Данную опцию также можно переключить на главной панели инструментов.<br>
  Вместо $EXTERNAL можно использовать короткий вариант $E.
<p>Синтаксис:
<div class="mycode5"><span class="general1-directive">{$EXTERNAL}</span></div>
<p>или
<div class="mycode5"><span class="general1-directive">{$E}</span></div><br>

<hr><br><p><a name="CLEO"><b>$CLEO</b></a>
<p>Данная директива является аналогом директивы $E, однако полученный файл автоматически копируется в директорию ‘игра\CLEO’, и получает расширение, указанное в директиве.
<p>
Синтаксис:
<div class="mycode5">
<span class="general1-directive">{$CLEO
 &lt;расширение файла&gt;}</span></div>
<p>
Например,
<div class="mycode5">
<span class="general1-directive">{$CLEO .cm}</span></div>
<p>
или
<div class="mycode5">
<span class="general1-directive">{$CLEO}</span> <span class="general1-comment">// файл получит расширение по умолчанию - .cs</span></div>
<p>
Таким образом, данная директива является идеальным решением для написания <a href="Cleo_SCRIPT.htm">CLEO-скриптов</a>

<hr><br><p><a name="NOSOURCE"><b>$NOSOURCE</b></a>
<p>Эта директива запрещает компилятору добавлять в тело скрипта его исходный код. По умолчанию, при включенной опции <a href="O_101.htm#SCM">Добавлять доп. информацию в SCM</a>, Sanny Builder добавляет исходный код в тело скрипта (только при наличии директивы <b>$EXTERNAL</b> или <b>$CLEO</b>). Данная директива изменяет поведение компилятора, не позволяя включать исходник в скомпилированный файл.
<p>Синтаксис:
<div class="mycode5">
<span class="general1-directive">{$NOSOURCE}</span></div>

<hr><br><p><a name="OPCODE"></a><b>$OPCODE</b>
<p>Эта директива позволяет добавить новый опкод напрямую через скрипт. Обычно описания всех опкодов содержатся в <a href="gta_ini.htm">специальном файле</a>, по одному для каждой игры. Но иногда необходимо добавить новый опкод для работы в текущем скрипте. Директива $OPCODE делает это возможным без редактирования оригинального файла с опкодами.
<p>Директива принимает описание опкода в <a href="gta_ini.htm#syntax">том же синтаксисе</a>, что и файл INI.
<p>Например,
<div class="mycode5"><span class="general1-directive">{$OPCODE 0CCC=1,my_new_opcode %1d%}</span></div>
<p>Директива также принимает имя файла в качестве параметра. Этот файл должен содержать в себе только описания опкодов, которые будут загружены компилятором. Если не указан глобальный путь к файлу, компилятор ищет его по <a href="#rules">тем же правилам, что и в директиве $INCLUDE</a>.
<p>Например,
<div class="mycode5"><span class="general1-directive">{$OPCODE additional_opcodes.ini}</span></div>
<p>Если директива использована без какого-либо параметра, это ведет к перезагрузке оригинального списка опкодов и отмене всех сделанных изменений.
<p>Например,
<div class="mycode5"><span class="general1-directive">{$OPCODE}</span></div>
<p>Вместо $OPCODE можно использовать короткий вариант $O.

</TD>
          <TD width=5
        background="rtd.gif"></TD></TR></TBODY></TABLE>
      <TABLE cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD width=5><IMG height=20
            src="img/ru/mtdlbot.png" width=5 border=0></TD>
          <TD align=left
            background="mtdbgbot.png"> </TD>
          <TD class=ninfo align=right
          background="mtdbgbot.png">&nbsp;
            </TD>
          <TD width=5><IMG height=20
            src="img/ru/mtdrbot.png" width=5
        border=0></TD></TR></TBODY></TABLE></DIV>
<p></TD></TR><td width="100%"></TBODY></TABLE>
</TABLE></body></html>
