<!DOCTYPE HTML>
<html lang="ru">
<head>
  <title>Условия</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../../style/style.css">
</head>
<body>
Сейчас я расскажу вам об операторах перехода. Переходы бывают условные и безусловные. Безусловные переходы бывают двух типов - с возвратом и без возврата. Для перехода с возвратом используется команда gosub @"Туда надо перейти", а для безвозвратного перехода существует jump @"Туда надо перейти". Отличие возвратного перехода от безвозвратного в том, что при возвратном переходе скрипт, дойдя до строчки gosub @"Туда надо перейти" будет выполнять всё после объявления лэйбла "Туда надо перейти" до тех пор, пока скрипт не встретит команду return, после чего выполнение перейдет к строчке после gosub @"Туда надо перейти", а при безвозвратном переходе после строчки jump @"Туда надо перейти" действие перейдет к лэйблу "Туда надо перейти" и все команды после jump будут проигнорированы. Условные переход всегда безвозвратные. О переходах смотреть также [здесь](#).
Условный переход всегда происходит после выполнения какого-либо условия. Все условия состоят из трёх частей:
1 - объявление самого условия.
2 - написание подусловий.
3 - что делать после (не) выполнения или просто-напросто переход.
Любое условие начинается со строки с текстом "if", если вы хотите, чтобы все подусловия (ещё их называют проверки) вашего условия выполнялись, то после "if" надо ставить "and" (между ними пробел), а если хотите, чтобы была проверка на выполнение хотя бы одного подусловия, то вместо "and" ставьте "or".

Например:

1) Проверка с выполнением всех подусловий:

```sb3
create_thread @Test1 
  
:Test1
wait 0
if and
  0102: actor $PLAYER_ACTOR stopped_near_point_on_foot $X $Y $Z radius $X_R $Y_R $Z_R sphere 0
  8184: not actor $PLAYER_ACTOR health >= 99
jf @Test1
actor.health($PLAYER_ACTOR) = 100
end_thread 
```

Принцип таков:
Если игрок(CJ) остановился по заданным координатам `$X $Y $Z`, точнее в радиусе `$X_R $Y_R $Z_R` от этих координат, и если его жизни меньше 100, то его жизнь опять станет равной 100. Параметр 0 в конце первого подусловия указывает, что игрок останавливается не в сфере(красный маркер). Если параметр был бы равен 1, то надо было бы создать сначала сферу, но о сферах потом. Опкод `jf @Test1` делает переход на `Test1`, если оба наших условия не выполнились.

2) Проверка с выполнением хотя-бы одного подусловия:

```sb3
create_thread @Test2

:Test2
wait 0
if or
  0102: actor $PLAYER_ACTOR stopped_near_point_on_foot $X $Y $Z radius $X_R $Y_R $Z_R sphere 0
  8184: not actor $PLAYER_ACTOR health >= 99
jf @Test2
actor.health($PLAYER_ACTOR) = 100
end_thread
```

Тут описано, что если игрок остановился в заданном радиусе от точки с координатами `$X $Y $Z` или если жизнь игрока стала меньше 100, то жизнь станет равна 100. Тут при выполнении хотя бы одного подусловия, будет выполнятся наше действие, т.е жизнь CJ'я станет 100.
Жизнь - целое число, а вот координаты и радиусы - дробные. Если даже вам надо использовать радиус равный 10, то надо написать 10.0.
Чтобы поток не был одноразового использования надо в конце вместо "end_thread" поставить "jump на начало", в данном случае - это `Jump @Test2`.
Вот вам пример первого(Test1) скрипта, но уже с координатами, радиусами... :

```sb3
create_thread @Example1 

:Example1
wait 0
if and
  0102: actor $PLAYER_ACTOR near_pt 2505.4812 -1687.4213 13.5543 radius 10.0 10.0 10.0 sphere 0
  8184: not actor $PLAYER_ACTOR health >= 99
jf @Example1
actor.health($PLAYER_ACTOR) = 100
jump @Example1
```

Если жизнь игрока меньше 100, и он стоит около гаража CJ'я, то его жизнь становится равной 100. Заметьте, что этот скрипт зациклен, он работает всегда, потому что есть переход в его конце на его начало.
С самого начала вставляйте "create_thread @Example1" после другого "create_thread", второй можно найти с помощью поиска. Потом ищем "----Mission 0----" и перед ней вставляем всё, что идёт в нашем скрипте начиная с ":Example1" заканчивая "jump @Example1" включительно. Жмём "F7", и ждём, пока пройдёт компиляция. Когда закомпилировалось жмите "F8" - запуск SA и начинайте новую игру.
\n
[red][Внимание!] В проверках существует только знак ">", знака "<" не существует, вместо него можно перед всем опкодом написать слово "not", это будет равносильно знаку "<", это применимо к командам без кодовых слов. В проверках-утверждених (в которых нет слова "not") опкод (кодовое слово) нач- ся с "0", а во всех проверках-отрецаниях используется тот же самый опкод, но уже вместо "0" там ставится цифра "8". Поэтому если у вас есть утверждение, то вы можете, поменять первую цифру, т.е. "0" на "8" и после знака ":" поставить "not", и это уже будет проверка-отрецание и наоборот.
Например:
Вот у меня есть проверка "игрок плавает в воде", она имеет следующий вид:

```sb3
:Label1
wait 0 ms
if // если у нас только одно подусловие или проверка, 
// то не "or" не "and" писать не надо.
0965: actor $PLAYER_ACTOR swimming_in_water
jf @Label1 // если подусловие не выполнилось, то переходим на начало.
```

Допустим у меня в скрипте должны выполнятся действия, когда игрок не в воде, а у меня в проверке написано, что действие скрипта дальше не пойдёт, если игрок не будет в воде, следовательно надо сделать проверку "игрок не плавает". Заменяем первоначальную проверку проверкой, противоположной по значению. И вот, что получилось:
```sb3
8965: not actor $PLAYER_ACTOR swimming_in_water
```
Что я сделал, я заменил первую цифру опкода,т.е. "0" на "8" и после двоеточия поставил слово "not".
А если у вас есть проверка-отрецание и вам надо сделать проверку-утверждение, то ищите первую цифру опкода (она должна быть - 8), затем меняйте её на 0, убирайте слово "not" и получите свою проверку-утверждение.
Это можно делать со всеми проверками, в которых есть кодовые слова.
Максимальное число проверок - 7 штук, если надо больше, то разбейте их на несколько частей,
например:
У нас есть 10 моделей, которые мы должны проверить на загруженность, но макс. кол-во проверок всего лишь 7, поэтому разбиваем проверки на две части, в первой будет 7, а во второй 3, и вот, что получается:

````sb3
:Test
wait 0
if and
  model.Available(#1)
  model.Available(#2)
  model.Available(#3)
  model.Available(#4)
  model.Available(#5)
  model.Available(#6)
  model.Available(#7)
jf @Test
if and
  model.Available(#8)
  model.Available(#9)
  model.Available(#10)
jf @Test
```

Вот такая проверочка вышла. Если что-то не понятно, то заходите на [https://gtamaps.net/forum](https://gtamaps.net/forum) .
Cам игрок тоже явл. актёром, только когда мы работаем с опкодами (командами) в которых есть слово "player" надо использовать `$PLAYER_CHAR`, а когда работаем с актёрами, то `$PLAYER_ACTOR`.

<script src="../../js/main.min.js"></script>