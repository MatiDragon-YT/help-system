<!DOCTYPE HTML>
<html lang="ru">
<head>
  <title>Quick Start. Часть 2</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../../style/style.css">
</head>
<body>
Рассмотрим подробнее дополнительные нововведения в язык скриптов.

В [предыдущей статье](qsp1.md), мы говорили о том, что все математические и арифметические выражения можно писать без опкодов. Это значительно удобнее и быстрее. Однако в компилятор Sanny встроены команды, позволяющие сократить даже простые выражения.

1) Команда **Inc**. Эта команда представляет собой альтернативу обычному сложению. Она увеличивает значение первого параметра на число, переданное вторым параметром. Первым может стоять переменная (типа Integer или Float) или свойство класса

```sb3
$Var += 10
Inc($Var, 10)
```

К переменной `$Var` в обоих вариантах будет прибавлено 10. 
Напомню, что если второе число целое (Integer), а переменная типа Float, то компилятор автоматически преобразует число в дробное. 
Данную команду удобно использовать, если вам нужно лишь прибавить единицу к переменной, поскольку второй параметр по умолчанию равен 1

```sb3
$Var += 1 
Inc($Var)
```

Оба варианта равнозначны.
В качестве первого параметра может стоять свойство класса. Подробнее о них будет рассказано в отдельной статье, сейчас я лишь приведу пример:

```sb3
0109: player $PLAYER_CHAR money += 1 
Player.Money($PLAYER_CHAR) += 1 
Inc(Player.Money($PLAYER_CHAR)) 
```

Все три варианта имеют одинаковое значение: количество денег игрока будет увеличено на единицу.

2) Команда **Dec**. Это замена операции вычитания:

```sb3
$Var -= 3 
Dec($Var, 3) 
```

На нее распространяются все написанное выше, за исключением примера со свойством. Дело в том, что свойство Money у игрока может только увеличиваться (опкод 0109). Опкода для вычитания денег нет. Поэтому выражение типа `Player.Money($PLAYER_CHAR) -= 1` работать не будет. Данное ограничение будет преодолено в следующих версиях SB.

3) Команда **Mul**. Операция умножения. Все тоже самое, за исключением того, что по умолчанию второй параметр равен 2:

```sb3
$Var *= 2 
Mul($Var) 
```
4) Заключительная арифметическая операция - деление. Для нее есть команда **Div**, которая без второго параметра делит переменную надвое:

```sb3
$Var /= 2 
Div($Var) 
```
Во всех четырех случаях вторым параметром может стоять переменная. Однако тогда типы обоих переменных должны быть определены в блоке var..end.

5) Процедура **SQR** вычисляет квадрат переменной. Т.е. она является заменой операции умножения переменной саму на себя:

```sb3
$Var *= $Var 
Sqr($Var) 
```
Тип переменной, как вы надеюсь поняли, должен быть известен компилятору.

6) Функция **Random** возвращает случайное число в интервале между числами, переданными в качестве параметров. Она представляет собой замену сразу двух опкодов:

```sb3
0208: $Var = random_float 10.0 100.0 
0209: $Var = random_int 10 100 
```

Оба варианта могут быть представлены в виде

```sb3
$Var = Random(10, 100) 
```

Как видите, компилятор сам выбирает опкод в зависимости от типа переменной, в которую записывается результат функции (`$Var`) Если ее тип неизвестен, либо это не Integer или Float, компилятор сообщит об ошибке.
В качестве параметров, конечно же, могут быть и переменные. Однако их тип не проверяется.
Следующая команда будет, возможно, трудна для восприятия. Для этого необходимо представлять как в main.scm хранятся переменные и что такое DMA. Это выходит за рамки данной статьи, хотя возможно будет впоследствии описано. Итак, команда **Alloc**. Она устанавливает адрес памяти для переменной с символьным именем:

```sb3
Alloc($PLAYER_CHAR, 10) 
```

Переменная `$PLAYER_CHAR` после этого будет компилироваться как `$10`.
При помощи команды **Alloc** вы можете выстроить группу переменных в ряд, превратив их таким образом в элементы массива:

```sb3
Alloc($Array, 40) 
Alloc($Value2, 41) 
Alloc($Value3, 42) 
Alloc($Value4, 43) 
```

Эти переменные представляют теперь собой массив. Теперь вы можете использовать такой код:

```sb3
Alloc($Array, 40) 
Alloc($Value2, 41) 
Alloc($Value3, 42) 
Alloc($Value4, 43)
var 
$Array: array 4 of Integer 
$Result: Int 
end 

$Value3 = 100 // в третий элемент массива записываем 100

$Index = 2 
// смещение от начала массива -> $Value3, не забывайте, что счет идет от нуля

$Result = $Array[$Index]
// будет прочитана третья ячейка, начиная с первого элемента

Player.Money($PLAYER_CHAR) += $Result // + 100 
```

Конечно, здесь можно в качестве альтернативы использовать "чистый" DMA, т.е. цифровые имена переменных (`$40`, `$41`, `$42` и т.д.), но с символьными именами работать приятнее.
Заключительная на сегодня возможность - это замена номеров миссий. Любая миссия запускается командой start_mission . Этот номер определяется в блоке DEFINE MISSION:

```sb3
DEFINE MISSIONS 135 
DEFINE MISSION 0 AT @INITIAL 
DEFINE MISSION 1 AT @INITIL2 
DEFINE MISSION 2 AT @INTRO 
```
Однако запоминать эти номера не всегда удобно. Поэтому в SB была добавлена возможность заменить номер миссии на ее имя. Имя в данном случае - это имя метки, написанной в этом же блоке. Таким образом, для запуска 2-й миссии достаточно написать

```sb3
start_mission intro 
```

Для пущего удобства в SB было встроено еще две возможности:
1) [замена всех номеров на имена при декомпиляции](../editor/options/general.md#replace-mission-numbers).
2) можно вызвать список имен нажатием **Ctrl+Space**. Курсор должен стоять после команды start_mission.

<script src="../../js/main.min.js"></script>