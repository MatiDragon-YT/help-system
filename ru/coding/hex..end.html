<!DOCTYPE html>
<html lang="ru">
<head>
  <title>HEX..END</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="../../style/style.css">
</head>
<body>

Sanny Builder поддерживает запись произвольных значений в выходной файл без какой-либо обработки и проверки.

{% hint style="warning" %}
Используйте эту возможность только в том случае, если вы знаете, что делаете. Любые ошибки могут повредить файл и его невозможно будет прочитать в игре или в скриптовом редакторе.
{% endhint %}

## Синтаксис

`hex  
<последовательность байтов>  
end`

`последовательность байтов` - одна или несколько пар цифр в [16-ричном формате](data-types.md#chisla-v-16-richnom-formate). Каждая пара представляет собой один байт, который будет записан в файл. Все пробелы игнорируются. Если число символов в последовательности нечетное, к последнему значению слева дописывается `0`:

```text
hex
    04 00 02 0800 04 1
end
```

Эта последовательность является бинарным представлением команды `0004: $2 = 1`. Игра сможет прочитать его и установит значение переменной `$2` в `1`.

В конструкции `HEX..END` также можно использовать [строковые литералы](data-types.md#strokovye-literaly), [метки](data-types.md#metki), [глобальные переменные](variables.md#globalnye-peremennye), [имена моделей](data-types.md#imena-modelei). Они компилируются без предшествующего байта, указывающего на тип данных.

```text
:get_offset
hex
    04 00 02 $PLAYER_CHAR 01 @get_offset
end
```

Это эквивалентно команде  `0004: $PLAYER_CHAR = @get_offset`

Строковые литералы, заключенные в двойные скобки, компилируются как последовательность символов:

```text
hex
    "This is a string"
end
```

## Экранированные последовательности

В строках допускается использование следующих управляющих символов:

<table>
<thead>
<tr>
<th>Имя</th>
<th>Последовательность</th>
<th>Вывод в файл</th>
</tr>
</thead>
<tbody>
<tr>
<td>пустой символ</td>
<td>\0</td>
<td>00</td>
</tr>
<tr>
<td>возврат на один шаг</td>
<td>\b</td>
<td>08</td>
</tr>
<tr>
<td>табуляция</td>
<td>\t</td>
<td>09</td>
</tr>
<tr>
<td>перевод каретки</td>
<td>\n</td>
<td>0A</td>
</tr>
<tr>
<td>возврат каретки</td>
<td>\r</td>
<td>0D</td>
</tr>
<tr>
<td>запись произвольного байта</td>
<td>\x`nn`</td>
<td>`nn`</td>
</tr>
<tr>
<td>запись произвольного символа</td>
<td>`символ`</td>
<td>`символ`</td>
</tr>
</tbody>
</table>


```text
hex
    "\0\b\t\n\r\xDD"
end
```

В файл будет записана последовательность байтов `00 08 09 0A 0D DD`.

{% hint style="info" %}
В настоящее время несколько подряд идущих пробелов в строке конвертируются в один пробел. Например, строка `"This    is  a     string"` будет сконвертирована в `"This is a string"`. Используйте символ `\` чтобы добавить дополнительные пробелы в строку: `"This \ \ \ is \ a \ \ \ \ string"`.
{% endhint %}

## Использование типа aDMA

Допускается использование типа данных [aDMA](data-types.md#peremennye), чтобы записать произвольное число в выходной файл. Число после знака `&` может быть как положительным, так и отрицательным, в десятичном формате или шестнадцатиричном.

```text
hex
    &1000 &-0xA33500 
end
```

В файл будет записана последовательность байтов `E8 03 00 CB 5C FF`.

<script src="../../js/main.min.js"></script>