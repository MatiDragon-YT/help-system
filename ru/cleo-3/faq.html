<!doctype html>
<html lang="ru">
<head>
	<title>FAQ</title>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="../../style/style.css">
</head>
<body>

**Q: Где можно ознакомиться со списком новых опкодов и значениями параметров?**

A: [смотрите здесь](opcodes.md).

---

**Q: Правда ли, что можно добавлять новые скрипты и не начинать новую игру?**

A: Да, это является основным нововведением CLEO 3. Подробнее о новом способе скриптинга написано здесь: [CLEO3: скрипты](scripts.md).

---

**Q: Как использовать в скрипте модель, которая обычно содержится в списке DEFINE OBJECT?**

A: CLEO-скрипты содержатся в scm-файлах без заголовка, т.е. являются аналогом внешних скриптов из файла script.img. Поэтому в них нет такого понятия как DEFINE OBJECT. Чтобы использовать такую модель, нужно указать вместо #имени ее глобальный ID (число).

Вы можете воспользоваться встроенной в SB [функцией поиска](../editor/hotkeys.md#CtrlAltH) ID модели (Ctrl+Alt+H).\
[Также вы можете воспользоваться способом, описанным здесь.](#! `$("#one").toggle()`)

:::d-none my-3#one
Если вам потребуется в скрипте использовать глобальный ID модели из списка импортирумых моделей (DEFINE OBJECTS), вы можете прочитать его из адреса памяти игры, используя следующую формулу:

```sb3
MA = -4982 + (ModelID * -7)
```

Например, чтобы прочитать глобальный ID модели INFO используйте следующий код:

```sb3
0@ = #INFO
0@ *= -7
0@ += -4982
0084: $modelID = &0(0@,1i)
```

в modelID будет записано 1239. 

вот пример цикла, который выводит по очереди все ID моделей из стандартного майна

```sb3
03C4: set_status_text_to $modelID 0 'FEC_NMN'

 // -4982 + (ModelID * -7)
for 1@ = -1 downto -388 // #INFO downto #SFCOPDR
 0085: 0@ = 1@ 
 0@ *= -7
 0@ += -4982
 0084: $modelID = &0(0@,1i) 
 wait 1000
end // for
```
\
:::right
[:note: Свернуть](#! `$("#one").toggle()`)
:::

:::

---

**Q: Можно ли писать CLEO-скрипты в других редакторах?**

A: Если вы по каким-то причинам не хотите или не можете использовать SB в качестве редактора скриптов, это не мешает вам писать скрипты для CLEO 3. Для этого вам нужно использовать первый способ написания скрипта, [описанный здесь](scripts.md) (извлечение скрипта из script.img).

---

**Q: Для чего в начале некоторых скриптов стоит опкод 0000?**

A: Это связано с некорректной обработкой скриптовым движком игры "нулевых переходов" (т.е. переходов на самое начало внешнего скрипта или миссии). Если скрипт представляет собой сплошной цикл, то этот опкод 0000 предназначен для создания минимального смещения от начала скрипта (эдакий буфер). Вместо 0000 можно использовать, например, wait 0.\
[Подробнее смотрите здесь.](#! `$("#two").toggle()`)

:::d-none my-3#two

Скриптовый движок SA имеет один неприятный баг, связанный с метками. Вы не можете осуществить переход из тела внешнего скрипта к его началу, т.е. сделать jump на самую первую метку.

```sb3
DEFINE SCRIPT TEST_SCR AT @TEST_SCR
...


//-------------External script (TEST_SCR)---------------

:TEST_SCR
wait 0
jump @TEST_SCR // этот опкод вызовет ошибку
```

Поэтому, если внешний скрипт представляет собой сплошной цикл, то нужно вставить какой-то опкод в начале, а затем метку для перехода:

```sb3
DEFINE SCRIPT TEST_SCR AT @TEST_SCR
...


//-------------External script (TEST_SCR)---------------

:TEST_SCR
0000: // можно вставить 03A4

:TEST_SCR_1
wait 0
jump @TEST_SCR_1 // этот опкод будет работать.
```

Тот же баг проявляет себя и в миссиях, но там переход к самому началу почти никогда не требуется.\
\
:::right
[:note: Свернуть](#! `$("#one").toggle()`)
:::

:::

---

**Q: Почему в CLEO-скриптах нельзя использовать глобальные переменные? Что тогда использовать?**\
\
[Подробнее смотрите здесь.](#! `$("#three").toggle()`)

:::d-none my-3#three
Когда мы компилируем main.scm вместе со всеми миссиями и скриптами, все глобальные переменные получают свой ID (порядковый номер). Часть из них получает ID всегда один и тот же (например, $PLAYER_CHAR компилируется как $2, $PLAYER_ACTOR - $3 и т.п.). Это справедливо для всех глобальных переменных, которые определены в CustomVariables.ini

Этот порядковый номер означает номер ячейки в памяти игры, где хранится значение переменной. Понятное дело, этот номер должен быть уникальным для каждой переменной. Иными словами, каждая переменная должна быть скомпилирована с уникальным ID.

Все остальные переменные компилируются следующих образом. Если имя переменной не найдено в CustomVariables.ini, то она компилируется с номером, который идет следом за наибольшей использованной переменной в скрипте. Звучит сложновато, поэтому пояcню на примере:

Простой скрипт из 2х строк:

```sb3#a
$PLAYER_CHAR = 1
$MYVAR = 1
```

`$PLAYER_CHAR` компилируется как `$2`. Значит, переменная `$MYVAR`, которая не содержится в CustomVariables.ini и имя которой не числовое, будет скомпилирована как `$3`. (на самом деле там будет не `$3`, потому что `$3` зарезервировано для `$PLAYER_ACTOR`, поэтому `$MYVAR` получит первое свободное имя - `$4`.

Другой пример

```sb3
$PLAYER_CHAR = 1
$MYVAR = 1
$100 = 1
```

Наибольшая переменная в скрипте теперь `$100`, поэтому `$MYVAR` станет `$101`.

Такой механизм позволяет присвоить каждой переменной свое уникальное имя.

В main.scm все новые переменные получают имена при компиляции начиная с $10948, т.к. $10947 наибольшая переменная, использованная в оригинальном main.scm.

Теперь вернемся к CLEO-скриптам. Каждый раз, когда мы компилируем новый скрипт, компилятор не знает ничегошеньки про состояние main.scm и сколько переменных в нем использовалось. Он именует переменные с нуля каждый раз. Это значит, что если ты сделаешь два скрипта, в которых будет:

в одном скрипте

```sb3
$MYVAR = 1
```

в другом скрипте

```sb3
$MYVAR1 = 1
```

то обе переменные будут скомпилированы как:

```sb3
$4 = 1
```

несмотря на то, что имена у них разные. И каждый раз компилятор будет в новом клео-скрипте именовать переменные, начиная с `$4`. Эффект, думаю, ясен. Переменные будут использовать одну и ту же ячейку памяти и менять значения друг друга. Если ты в одном скрипте запишешь актера в `$MYVAR`, а в другом в `$MYVAR1 = 0`, то когда первый скрипт обратится к `$MYVAR`, он прочитает не актера, а `0`, т.к. обе переменные используют 4-ю ячейку памяти.

Другая ситуация - это выход за пределы памяти для глобальных переменных. Например, обычный stripped имеет размер памяти для глобальных переменных в 409 ячеек, поскольку наибольшая использованная переменная `$ONMISSION` это `$409`. Предположим, мы создали клео-скрипт:

```sb3
$ONMISSION = 1
$MYVAR = 0
```

Как будет скомпилирована переменная `$MYVAR`, если вы поняли, о чем я говорил выше ? Правильный ответ `$411`. `$ONMISSION` это `$409`, поэтому переменная должна бы стать `$410`, но этот ID уже зарезервирован для `$Help_SprayCan_Shown` (см. CustomVariables.ini). Поэтому первый свободный номер это `$411`.

Вернемся теперь к stripped. Размер памяти-то у него так и остался - `409` (если бы `$MYVAR = 0` компилировалась в майне, то память была бы увеличена до `411`). Поэтому когда клео-скрипт будет работать с переменной `$MYVAR`, ее значения будут читаться и писаться за пределами дозволенной области памяти. В худшем случае, такие переменные будут менять код самого main.scm (опкоды и параметры), что неминуемо повлечет вылет.
\
:::right
[:note: Свернуть](#! `$("#three").toggle()`)
:::

:::
\
\
[А также здесь.](#! `$("#four").toggle()`)

:::d-none my-3#four
Глобальные переменные ($) вообще не рекомендуется использовать в CLEO-скриптах, не важно, каким способом их называть. Есть только 2 исключения: 1) это общераспространенные переменные типа $PLAYER_CHAR, $PLAYER_GROUP, $ONMISSION и 2) неиспользуемые переменные типа $30, $56. В любом случае к использованию глобальных переменных нужно подходить очень осторожно, иначе не минуемы различные глюки в игре.

Зато СВОБОДНО, БЕЗ ОГРАНИЧЕНИЙ можно пользоваться локальными переменными. Мало 32-х переменных? Есть масса способов как обойти ограничение (начиная от простой оптимизации, заканчивая использованием scm-функций - 0AB1, 0AB2).

Если неудобно пользоваться локальными переменными из-за их имени (согласен, 1@ не всегда явно выражает смысл переменной), пользуйтесь конструкцией **CONST..END** Пара строк 

```sb3
const
TRAIN_MODEL = 1@
end
```

позволяет использовать в скрипте слово TRAIN_MODEL, которое на самом деле будет обозначать локальную переменную и компилироваться соответственно. Например, `TRAIN_MODEL = 400` - это в переменную `1@` записали число `400`. И все, больше никаких проблем из-за глобальных переменных.
\
:::right
[:note: Свернуть](#! `$("#four").toggle()`)
:::

:::

---

**Q: Можно ли в CLEO-скриптах использовать опкоды set_status_text и set_timer?**\
\
[Подробнее смотрите здесь.](#! `$("#five").toggle()`)

:::d-none my-3#five

В CLEO скриптах в настоящее время нельзя использовать опкоды set_status_text и set_timer, а также сопутствующие им опкоды. Связано это с тем, что эти опкоды требуют задания глобальной переменной, которые, за редким исключением, использовать в CLEO-скриптах нельзя.

Поскольку написать альтернативу этим опкодам довольно непросто, я решил пойти другим путем. Я написал 4 функции, которые работают аналогично опкодам 03C3, 03С4, 014F, 0151, только принимают в качестве переменной - локальную переменную. Это позволяет использовать статус_текст и таймеры в CLEO-скриптах и CLEO-миссиях.

[red][Внимание!] Для корректной работы функций нужен CLEO 3 v3.0.950 и выше

Функции работают только в GTA: SA v1.0

```sb3
:AddStatusText                 
0AB1: call_scm_func @__VarToOffset 1 0@ 0@
0AB1: call_scm_func @__LabelToOffset 1 2@ 2@
0AA6: call_method 0x0044CDA0 struct 0x00BA1788 num_params 4 pop 0 ( LINE = 3@ GXT = 2@ TYPE = 1@ VARNUMBER = 0@ )
0AB2: ret 0

:RemoveStatusText
0AB1: call_scm_func @__VarToOffset 1 0@ 0@
0AA6: call_method 0x0044CE80 struct 0x00BA1788 num_params 1 pop 0 ( VARNUMBER = 0@ )
0AB2: ret 0

:SetTimer
0AB1: call_scm_func @__VarToOffset 1 0@ 0@
0AB1: call_scm_func @__LabelToOffset 1 2@ 2@
0AA6: call_method 0x0044CD50 struct 0x00BA1788 num_params 3 pop 0 ( TYPE = 1@ GXT = 2@ VARNUMBER = 0@ )
0AB2: ret 0

:StopTimer
0AB1: call_scm_func @__VarToOffset 1 0@ 0@
0AA6: call_method 0x0044CE60 struct 0x00BA1788 num_params 1 pop 0 ( VARNUMBER = 0@ )
0AB2: ret 0

:__VarToOffset
0A9F: 1@ = current_thread_pointer
0A8E: 2@ = 1@ + 0xDC // mission Flag
0A8D: 2@ = read_memory 2@ size 1 virtual_protect 0
if
    2@ == 1
then
    1@ = 0x00A48960 // mission locals
else
    1@ += 0x3C
end
0@ *= 4
005A: 1@ += 0@ // address of the local variable 
1@ -= 0xA49960
0AB2: ret 1 1@

:__LabelToOffset
if
    0@ == 0
then
    0AB2: ret 1 0
end
0A9F: 1@ = current_thread_pointer
1@ += 0x10 
0A8D: 1@ = read_memory 1@ size 4 virtual_protect 0 // baseIP
0062: 1@ -= 0@ // label address
1@ += 3
0AB2: ret 1 1@

:StatusText
0900: 'BB_19'
0000:
```

Вот эти 4 функции.

1\. **AddStatusText** эмулирует опкод
```sb3
03C4: set_status_text $BEEFYBARON_SCORE type 0 GXT 'ZER2_43'.
```

Пример использования:
```sb3
0AB1: call_scm_func @AddStatusText 4 VARNUMBER = 33 TYPE = 0 GXT = @StatusText LINE = 3
```
Параметры: `VARNUMBER = 33` - это номер локальной переменной, значение которой будет выведено (т.е. `33@`)

`TYPE = 0` - как и в 03С4 тип статуса: полоска (1) или число (0).

`GXT = @StatusText` - это основное отличие от опкода. Напрямую передать строку в функцию нельзя (также как и в новый поток, например). Поэтому мы передаем метку, на которой стоит опкод 0900 с нужным текстом (GXT) (в данном случае `0900: 'BB_19'`). Можно добавить несколько подряд опкодов 0900, каждый со своим GXT и своей меткой, и передавать в функцию нужную метку. Надеюсь, с этим проблем не возникнет.
Можно вместо метки написать `0`, тогда будет выводиться только число, без текста слева.

`LINE = 3` - номер строки, на которой появится статус. Если равно 0, то статус добавится к первой свободной строке.

2\. **RemoveStatusText** эмулирует опкод
```sb3
0151: remove_status_text $1924
```

Пример использования:

```sb3
0AB1: call_scm_func @RemoveStatusText 1 VARNUMBER = 33
```
Параметр только один - номер локальной переменной, которая использовалась в AddStatusText.

3\. **SetTimer** эмулирует опкод
```sb3
03C3: set_timer_to $1923 type 1 GXT 'BB_19'
```

Пример использования:

```sb3
0AB1: call_scm_func @SetTimer 3 VARNUMBER = 1 TYPE = 1 GXT = @StatusText
```
Параметры VARNUMBER и GXT аналогичны AddStatusText. Параметр TYPE означает вид таймера: увеличивающийся или уменьшающийся.

4\. **StopTimer** эмулирует
```sb3
014F: stop_timer $1923
```

Пример использования:

```sb3
0AB1: call_scm_func @StopTimer 1 VARNUMBER = 1
```
**Параметр** - номер локальной переменной, которая использовалась в SetTimer.

Поскольку это лишь эмуляция настоящих опкодов, все ограничения сохраняются (1 таймер и 4 статуса).

Чтобы использовать эти функции, нужно скопировать их без изменений в ваш скрипт, изменить или добавить нужные GXT-ключи, и вызывать соответствующую функцию.

Вот пример скрипта, который в течение 10 секунд показывает состояние переменной 33@ (т.е. таймера) [status_text.cs](http://cleo.sannybuilder.com/scripts/status_text.cs)

:::right
[:note: Свернуть](#! `$("#one").toggle()`)
:::

:::

---

**Q: У меня есть код CLEO-скрипта, как получить из него .cs-файл?**

A: Для этого понадобится программа Sanny Builder 3.03 и выше (найти можно на этом же сайте). Скачайте ее, установите. Запустите, зайдите в опции (F10), укажите путь к папке игры. Теперь нажмите Файл-Создать (Ctrl+N), копируйте весь скрипт в окно редактора (начиная со слова `{$CLEO}`) и сохраните полученный текстовый файл. После этого нажмите F7. Если все прошло успешно, в папке игры в папке CLEO должен появиться новый .cs-файл. Если возникли ошибки при компиляции, попытайтесь исправить их, следуя советам из справки (она на русском языке!).

<script src="../../js/main.min.js"></script>