<!doctype html>
<html lang="es">
<head>
	<title>Opcodes</title>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="../../style/style.css">
</head>
<body>

El uso de los siguientes opcodes solo es posible en la biblioteca CLEO 3 instalada. Al compilar Sanny Builder comprueba si la biblioteca esta instalada y, de no ser asi, advierte que es necesario. Si escribe una secuencia de comandos utilizando estos opcodes, debe incluir tambien los archivos de la biblioteca para garantizar su funcionalidad al usuario final.

:::cols-3 cols-sm-4 pre p-4 center
[Opcode 0A8C](#0A8C)
[Opcode 0A99](#0A99)
[Opcode 0AA6](#0AA6)
[Opcode 0AB3](#0AB3)
[Opcode 0A8D](#0A8D)
[Opcode 0A9A](#0A9A)
[Opcode 0AA7](#0AA7)
[Opcode 0AB4](#0AB4)
[Opcode 0A8E](#0A8E)
[Opcode 0A9B](#0A9B)
[Opcode 0AA8](#0AA8)
[Opcode 0AB5](#0AB5)
[Opcode 0A8F](#0A8F)
[Opcode 0A9C](#0A9C)
[Opcode 0AA9](#0AA9)
[Opcode 0AB6](#0AB6)
[Opcode 0A90](#0A90)
[Opcode 0A9D](#0A9D)
[Opcode 0AAA](#0AAA)
[Opcode 0AB7](#0AB7)
[Opcode 0A91](#0A91)
[Opcode 0A9E](#0A9E)
[Opcode 0AAB](#0AAB)
[Opcode 0AB8](#0AB8)
[Opcode 0A92](#0A92)
[Opcode 0A9F](#0A9F)
[Opcode 0AAC](#0AAC)
[Opcode 0AB9](#0AB9)
[Opcode 0A93](#0A93)
[Opcode 0AA0](#0AA0)
[Opcode 0AAD](#0AAD)
[Opcode 0ABA](#0ABA)
[Opcode 0A94](#0A94)
[Opcode 0AA1](#0AA1)
[Opcode 0AAE](#0AAE)
[Opcode 0ABD](#0ABD)
[Opcode 0A95](#0A95)
[Opcode 0AA2](#0AA2)
[Opcode 0AAF](#0AAF)
[Opcode 0ABE](#0ABE)
[Opcode 0A96](#0A96)
[Opcode 0AA3](#0AA3)
[Opcode 0AB0](#0AB0)
[Opcode 0ABF](#0ABF)
[Opcode 0A97](#0A97)
[Opcode 0AA4](#0AA4)
[Opcode 0A98](#0A98)
[Opcode 0AA5](#0AA5)
[Opcode 0AB1](#0AB1)
[Opcode 0AB2](#0AB2)
:::

:::center h5
Opcodes de CLEO 2
:::

```sb3
0A8C: write_memory 0xC0BC15 size 1 value 1 virtual_protect 0
```
[0A8C][]**0A8C** escribe un valor a la memoria del juego.

**Parámetros:**
1. dirección de memoria (entero)
2. número de bytes a escribir: 1, 2 o 4 bytes
3. valor a escribir (cualquier número)
4. Virtual Protect:
- `0`: si la dirección es reescribible
- `1`: si la dirección de solo de lectura

---

```sb3
0A8D: $result = read_memory 1@ size 4 virtual_protect 0
```
[0A8D][]**0A8D** lee la memoria del juego y guarda el resultado en una variable.

**Parámetros:**
1. variable para guardar el resultado de lectura (cualquier variable o elemento de arreglo)
2. dirección de memoria para leer (entero)
3. número de bytes para leer: 1, 2 o 4 bytes
4. Virtual Protect:
- `0`: si la dirección es legible.
- `1`: si la dirección es ilegible

---

```sb3
0A8E: 4@ = 15 + 5 // int 
```
[0A8E][]**0A8E** suma dos valores y guarda el resultado en una variable.

**Parámetros:**
1. variable para guardar la suma (cualquier variable o elemento de arreglo)
2. primer elemento (entero)
3. segundo elemento (entero)

---

```sb3
0A8F: 0@ = 10@ - 3@ // int 
```
[0A8F][]**0A8F** resta un valor entero de otro y guarda el resultado en una variable.

**Parámetros:**
1. variable para guardar la diferencia (cualquier variable o elemento de arreglo)
2. minuendo (entero)
3. sustraendo (entero)

---

```sb3
0A90: $var(0@,10i) = 100 * 1@ // int 
```
[0A90][]**0A90** multiplica un numero entero por otro y guarda el resultado en una variable.

**Parámetros:**
1. variable para guardar producto (cualquier variable o elemento de un arreglo)
2. multiplicador (entero)
3. multiplicador (entero)

---

```sb3
0A91: $div = 1 / 5 // int
```
[0A91][]**0A91** divide un numero entero por otro y guarda el resultado en una variable sin el resto

**Parámetros:**
1. variable para guardar el resultado (cualquier variable o elemento de un arreglo) 
2. dividendo (entero)
3. divisor (entero)

---

```sb3
0A96: $ActorStruct = actor $PLAYER_ACTOR struct
```
[0A96][]**0A96** guarda el puntero a la estructura del actor en la memoria del juego. La estructura es un conjunto de diferentes valores como salud, coordenadas, etc. Conociendo la dirección de la estructura, es posible leer/reescribir estos valores usando 0A8D/0A8C.

**Parámetros:**
1. variable para guardar la dirección de la estructura
2. controlador de actor obtenido por el opcode del constructor (009A y similares)

---

```sb3
0A97: $CarStruct = car $MyCar struct
```
[0A97][]**0A97** guarda el puntero a la estructura del vehículo en la memoria del juego.

**Parámetros:**
1. variable para guardar la dirección de la estructura
2. controlador de vehiculo obtenido por el opcode del constructor (00A5 y similares)

---

```sb3
0A98: $ObjectStruct = object 0@ struct
```
[0A98][]**0A98** guarda el puntero a la estructura del objeto en la memoria del juego.

**Parámetros:**
1. variable para guardar la dirección de la estructura
2. controlador de objeto obtenido por el opcode del constructor (0107 y similares)

---

```sb3
0A99: chdir 0
```
[0A99][]**0A99** establece el directorio actual haciéndolo predeterminado.

**Parámetro:**
1. carpeta del directorio
- `0`: la raíz del juego
- `1`: la de archivos del usuario
- `<String>`: selecciona una carpeta en la raiz del juego

---

```sb3
0A9A: $hFILE = openfile "settings.ini" mode 0x72  // IF and SET
```
[0A9A][]**0A9A** abre el archivo para lectura y escritura. Este opcode se puede usar como una condición: si el archivo no estaba abierto, retorna False, de lo contrario True.

**Parámetros:**
1. variable para guardar el controlador de archivo
2. Nombre del archivo. Si la ruta es relativa, el archivo se abre de acuerdo con el directorio actual ([0A99](#0A99)).
3. modo de apertura de archivos:
- **Con CLEO 3 debia acerse con un numero hex.**
  - `0x72`: abre el archivo de texto para leer
  - `0x77`: abre el archivo de texto para escribir
  - `0x6272`: abre el archivo binario para leer
  - `0x6277`: abre un archivo binario para escribir
- **Desde CLEO 4 se puede configurar con un String**
  - `"rb"`: leer archivo binario
  - `"wb"`: escribir archivo binario
  - `"wb+"`: escribir archivo binario (créelo si no existe)
  - `"ab"`: anexar archivo binario (escribir al final)
  - `"ab+"`: anexar archivo binario (créelo si no existe)
  - `"rt"`: leer archivo de texto
  - `"wt"`: escribir archivo de texto
  - `"wt+"`: escribir archivo de texto (créelo si no existe)
  - `"at"`: anexar archivo de texto
  - `"at+"`: anexar archivo de texto (créelo si no existe)
  - `"rb+"`: leer/escribir archivo binario
  - `"rt+"`: leer/escribir archivo de texto

---

```sb3
0A9B: closefile $hFILE
```
[0A9B][]**0A9B** cierra el archivo y libera la memoria.

**Parámetro:** controlador de un archivo 

---

```sb3
0A9C: 0@ = file $hFILE size 
```
[0A9C][]**0A9C** guarda el tamaño del archivo en bytes en una variable.

**Parámetros:**
1. variable para guardar el resultado
2. controlador de un archivo

---

```sb3
0A9D: readfile $hFILE size 2 to $150
```
[0A9D][]**0A9D** lee el número especificado de bytes del archivo abierto y los escribe en la región de memoria a partir de la dirección donde está la variable.

**Parámetros:**
1. controlador de un archivo
2. número de bytes para leer del archivo 
3. variable para guardar el resultado. Si el número de bytes entregados es mayor a cuatro, el resto se escribirá en la siguiente variable ($151 en este caso), y así sucesivamente.

---

```sb3
0A9E: writefile $hFILE size 128 from 0@
```
[0A9E][]**0A9E** copia datos a partir de la dirección, donde está la variable (último parámetro), al archivo.

**Parámetros:**
1. controlador de un archivo
2. número de bytes a copiar
3. La variable indicaba la posición de inicio de la escritura de datos. Si el tamaño de los datos es superior a 4 bytes, el valor de la siguiente variable se leerá y escribirá en el archivo. En este ejemplo, el archivo mantendrá el volcado de todas las variables locales de un hilo (32 variables con 4 bytes de longitud para cada una = 128 bytes para copiar).

---

```sb3
0A9F: 0@ = current_thread_pointer
```
[0A9F][]**0A9F** guarda el puntero de hilo actual en una variable. Conociendo este puntero, es posible trabajar directamente con cualquier campo de subproceso, como el nombre del subproceso, sus variables locales, IP base, etc.

---

```sb3
0AA0: gosub_if_false @CREATE_NEW_ACTOR
```
[0AA0][]**0AA0** ejecuta un comando gosub si el resultado de la condición es falso. Excepto por esta diferencia, este opcode es el mismo que `004D: jump_if_false` y se puede usar en su lugar.

**Parámetro:** etiqueta donde se transfiere el hilo

---

```sb3
0AA1: return_if_false
```
[0AA1][]**0AA1** ejecuta una devolución si el resultado de la condición es falso. Este es similar al 004D y se puede usar en lugar de.

---

```sb3
0AA2: $hLIB = load_library "CLEO\version.dll" // IF and SET
```
[0AA2][]**0AA2** carga una librería DLL y almacena el controlador en una variable. Este opcode se puede usar como una condición: si la librería no se carga, retorna `False`, de lo contrario, `True`.

**Parámetros:**
1. variable para guardar el controlador en una librería (cualquier variable o elemento de arreglo)
2. un nombre de librería. Si la ruta es relativa (sin especificar un nombre de disco), el archivo DLL se busca relativamente del directorio activo actual ([0A99](#0A99)). Si no se especifica la extensión del archivo, se utilizará la extensión predeterminada (.DLL).

---

```sb3
0AA3: free_library $hLIB
```
[0AA3][]**0AA3** descarga la librería y libera la memoria.

**Parámetro:** controlador de la librería

---

```sb3
0AA4: $hPROC = get_proc_address "GetVersion" library $hLIB // IF and SET
```
[0AA4][]**0AA4** retorna la dirección de la función DLL exportada especificada. Esta dirección se puede utilizar en los opcodes del tipo de llamada. Este opcode se puede usar como una condición: si no se encuentra la función, retorna `False`, de lo contrario, `True`.

**Parámetros:**
1. variable para guardar la dirección de la función.
2. nombre de función (un String directo ó en variable). Preste atención a que `get_proc_address` es sensible a mayúsculas y minúsculas. Si la función se exporta con el nombre `GetVersion`, significa que, por ejemplo, `get_proc_address "getversion"` no encontrará dicha función. Debe especificar el nombre exacto. Recuerde también que Sanny Builder compila todas los Strings en mayúsculas de forma predeterminada. Significa que este ejemplo se compilará como `"GETVERSION"`, por lo que la función `GetVersion` no se volverá a encontrar. Para evitar eso, [seleccione el caso tipográfico "Camel"](../editor/options/formats.md) en las preferencias del programa.
3. controlador de librería cargada ([0AA2](#0AA2))

---

```sb3
0AA5: call $hPROC num_params 1 pop 1 $param
```
[0AA5][]**0AA5** y los opcodes similares tienen un número variable de parámetros. Este opcode tiene al menos 3 parámetros, y también otros adicionales (pasados al proceso llamado), cuyo número y valores dependen del procedimiento llamado. El número total de parámetros adicionales debe ser igual al parámetro `num_params`. Cada parámetro pasado debe ser numérico (ajuste constante o variable), pero no un String.

**Parámetros:**
1. dirección del proceso llamado. Puede ser la dirección dentro de `gta_sa.exe` o dentro de un dll cargado.
2. número de parámetros para pasar al proceso.
3. número de parámetros que deben eliminarse de la pila después de la ejecución del proceso. Este valor tiene que estar dentro de un intervalo de cero a `num_params`. El valor exacto depende del convenio de llamada del procedimiento. Por lo general, los procedimientos exe no limpian la pila por sí mismos, por lo que el parámetro pop en su mayoría es igual a `num_params` (todos los parámetros pasados se eliminan de la pila después de la ejecución del proceso).

---

```sb3
0AA6: call_method $Destroy struct $CarStruct params 0 pop 0
```
[0AA6][]**0AA6** llama al proceso de la clase. Cada clase tiene un conjunto de procedimientos llamados métodos para operar con los datos de la clase (como las clases SB como referencia). Llamamos al método `Destroy` de la clase `CVehicle` en este ejemplo. Con una condición, es posible decir que este ejemplo es igual que el comando `Car.Destroy()`.

**Parámetros:**
1. dirección del proceso llamado. Puede ser la dirección dentro de `gta_sa.exe` o dentro de un dll cargado.
2. puntero a la estructura de clases (se puede obtener con los opcodes [0A96](#0A96) - [0A98](#0A98)).
3. número de parámetros a pasar
4. número de parámetros que se eliminarán de la pila después de la ejecución del método. Comúnmente, los métodos limpian la pila por sí mismos, por lo que el parámetro pop debe ser igual a 0.

---

```sb3
0AA7: call_function 0x569660 num_params 2 pop 2  $COORD_X $COORD_Y $GROUND
```
[0AA7][]**0AA7** funciona de manera similar a [0AA5](#0AA5) excepto que, además, hay una variable para mantener el resultado de la función llamada. Significa que el último parámetro aquí es siempre una variable. Por lo tanto, num_params no incluye este. Llamamos a la función en la dirección `0x569660` y le pasamos dos parámetros X e Y en este ejemplo. El resultado de la función se guardará en `$GROUND`.

**Parámetros:**
1. dirección del proceso llamado. Puede ser la dirección dentro de `gta_sa.exe` o dentro de un dll cargado.
2. número de parámetros a pasar a la función
3. número de parámetros que deben eliminarse de la pila después de la ejecución de la función. Consulte el [0AA5](#0AA5) para obtener una explicación.

---

```sb3
0AA8: call_function_method 0x4048E0 struct 0xB74494  num_params 1 pop 0 $MyCar 0@
```
[0AA8][]**0AA8** llama a una función de la clase y almacena el resultado en una variable que siempre es el último parámetro. El principio de funcionamiento es similar a los opcodes [0AA6](#0AA6) y [0AA7](#0AA7). Llamamos a la función en la dirección 0x4048E0 y le pasamos el controlador del vehículo como parámetro en este ejemplo. Struct `0xB74494` es una colección de todos los vehículos del juego. `0x4048E0` es una función que convierte el controlador del vehículo en su puntero de estructura (análogo del opcode [0A97](#0A97)). Este puntero se guardará en la variable `0@`.

**Parámetros:**
1. dirección del proceso llamado. Puede ser la dirección dentro de `gta_sa.exe` o dentro de un dll cargado.
2. puntero a la estructura de clases (se puede obtener con los opcodes [0A96](#0A96) - [0A98](#0A98)).
3. número de parámetros a pasar.
4. número de parámetros que se eliminarán de la pila después de la ejecución del método. Comúnmente, los métodos limpian la pila por sí mismos, por lo que el parámetro pop debe ser igual a 0.

---

```sb3
0AA9: is_game_version_original
```
[0AA9][]**0AA9** se utiliza como condición. Si trabaja con la versión 1.0 de SA original, devuelve `True`, de lo contrario, `False`. El opcode es útil para escribir un script multiversión.

---

```sb3
0AAB:  file_exists "CLEO\version.dll"
```
[0AAB][]**0AAB** comprueba si existe un archivo especificado. Esta verificación es parte de los códigos de operación 0A9A y 0AA2, por lo que no es necesario duplicarla.

**Parámetro:** Nombre del archivo. Si la ruta es relativa (sin especificar un nombre de disco), se busca relativamente del directorio activo actual ([0A99](#0A99)).

---

```sb3
0AAC: $hMP3 = load_mp3 "CLEO\playlist\01.mp3"
```
[0AAC][]**0AAC** carga un archivo mp3 y almacena un controlador en una variable.

**Parámetros:**
1. variable para guardar el controlador de mp3
2. nombre de archivo mp3. Si la ruta es relativa (sin especificar un nombre de disco), se busca relativamente del directorio activo actual ([0A99](#0A99)).

---

```sb3
0AAD: set_mp3 $hMP3 perform_action 1
```
[0AAD][]**0AAD** realiza la acción predefinida con el mp3 cargado.

**Parámetros:**
1. controlador de mp3 obtenido por 0AAC
2. un número para especificar una acción:
- `0`: detener
- `1`: reproducir
- `2`: pausar
- `3`: reanudar 

---

```sb3
0AAE: release_mp3 $hMP3
```
[0AAE][]**0AAE** libera el archivo mp3 y libera la memoria.

**Parámetro:** controlador de mp3 obtenido por 0AAC.

---

```sb3
0AAF: 0@ = get_mp3_length $hMP3
```
[0AAF][]**0AAF** almacena la duración de la pista en segundos del mp3 cargado en una variable.

**Parámetros:**
1. variable para almacenar el resultado
2. controlador del mp3 

---

```sb3
0AB0:  key_pressed 0x73
```

[0AB0][]**0AB0** se utiliza como condición. Este opcode comprueba si la tecla está pulsada en el teclado. Si la tecla con el código especificado está presionada, devuelve True, de lo contrario False.

**Parámetro:** código de la tecla virtual. Ver [aquí](../scm-documentation/virtual-key-codes.md) la lista de ellos.

---

:::center h5
CLEO 3 Opcodes
:::

```sb3
0A92: create_custom_thread "ShowTextBox.s"
```
[0A92][]**0A92** crea un nuevo hilo desde el archivo. Si el archivo tiene una extensión .cs, el hilo se crea automáticamente al iniciar el juego. Al crear un hilo personalizado, puedes pasarle hasta 34 parámetros, como en el opcode 004F.

**Parámetro:** nombre del archivo. El nombre debe ser especificado con una extensión si la tiene. El archivo se recupera relativamente del directorio 'game\CLEO' que es la ruta por defecto para cualquier archivo CLEO.

---

```sb3
0A93: end_custom_thread
```
[0A93][]**0A93** finaliza el hilo CLEO personalizado. Este opcode sólo debe utilizarse en los hilos de CLEO (ni en las misiones de CLEO, ni en el main.scm). En general, este opcode es un análogo del 004E.
Para detener una misión CLEO, utilice el opcode 004E.

---

```sb3
0A94: start_custom_mission "missions\CustomMission1"
```
[0A94][]**0A94** inicia una misión CLEO desde el archivo especificado como lo hace el 0147. Observe que no es necesario especificar la extensión del archivo. De hecho, el opcode buscará el archivo con la extensión .cm (Custom Mission). La misión se inicia desde el archivo CLEO\missions\CustomMission1.cm en este ejemplo.

**Parámetro:** nombre de archivo sin extensión. El archivo se recupera relativamente del directorio 'game\CLEO'.

---

```sb3
0A95: enable_thread_saving
```
[0A95][]**0A95** habilita la bandera de guardado para el hilo actual. Por defecto el estado de los hilos de CLEO no se guarda, y se ejecutan desde el principio cada vez que se inicia el juego. Para guardar el estado del hilo, sus variables locales y demás, añade este opcode al script.

---

```sb3
0AAA: 0@ = thread 'OTB' pointer
```
[0AAA][]**0AAA** comprueba si un hilo con el nombre dado está activo. Si es así, opcode almacenará la dirección de este hilo en una variable. Si no se encuentra un hilo con el nombre dado en la memoria del juego, el valor de la variable será 0.

**Parámetros:**
1 - una variable para almacenar el resultado de la búsqueda 
2 - un nombre de hilo a buscar

---

```sb3
0AB1: call_scm_func @GetSQR 1  10 $result
```
[0AB1][]**0AB1** llama a una función SCM, le pasa los parámetros y almacena el resultado en una(s) variable(s). Los valores de los parámetros pasados se copian a las variables locales en serie, luego la ejecución del hilo se transfiere a la etiqueta, ejecuta código allí y retorna después del opcode 0AB2.

**Parámetros:**
1. etiqueta (inicio de la función SCM)
2. número de parámetros a pasar

Luego están los parámetros pasados, un número de 10 en nuestro caso. Después deben estar las variables para almacenar el resultado de la función SCM ([ver 0AB2](#0AB2)).

---

```sb3
0AB2: ret 1 0@
```
[0AB2][]**0AB2** Este opcode transfiere la ejecución del hilo de vuelta al opcode 0AB1 y almacena los valores devueltos en sus variables. **El número total de valores devueltos debe ser igual al número de variables que almacenan el resultado en el 0AB1**. En este ejemplo el 0AB2 devuelve un valor, que es el valor de la variable `0@`, este valor se copiará a la variable $resultado (ver ejemplo 0AB1). Si el opcode 0AB2 no devuelve ningún valor, debe tener un `0` como único parámetro, y el propio 0AB1 que llama a dicha función no debe tener variables que almacenar.

**Parámetros:**
1. número de valores a devolver
Después están los valores devueltos.

---

Este es un ejemplo sencillo de la función SCM calculando el número cuadrado.

```sb3
0@ = 5
0AB1: call_scm_func @GetSQR 1 10 $result
end_thread

...

:GetSQR
006A: 0@ *= 0@ 
0AB2: ret 1 0@
```
<span id=0AB1></span>
Cómo funciona. En primer lugar, el juego llega al opcode 0AB1. El juego lee el número de parámetros a pasar (1) y sus valores (10). La variable 0@ del hilo actual equivale a 10 (si hubiera más parámetros a pasar, el siguiente se copiará al 1@, luego al 2@ y así sucesivamente). Después el hilo salta a la etiqueta @GetSQR. Aquí se calcula el número cuadrado (de un valor en el 0@). De nuevo, si hubiera más parámetros, se pueden tener en cuenta los valores de 1@, 2@, etc., si fuera necesario. Después del cálculo, el juego llega al opcode 0AB2. El valor de 0@ es igual a 10*10 = 100 en este momento. Entonces sucede lo siguiente: el valor(es) devuelto(s) (0@) es copiado a la(s) variable(s) que está(n) escrita(s) en el opcode 0AB1 que llamó a esta función. En nuestro ejemplo dicha variable es $resultado. Después de almacenar el resultado, el hilo vuelve al 0AB1 y llega al comando end_thread. El valor de $resultado es igual a 100 (que es el cuadrado de 10) en este momento.
Finalmente decir que 0AB2 podría devolver no sólo los valores de las variables, sino también las constantes numéricas. Por ejemplo, `0AB2: ret 1 1` almacenará siempre 1 en el resultado.

También hay que prestar atención a que las variables locales permanezcan sin cambios después de la llamada a la función. En este ejemplo, la variable 0@ contiene un valor de 5 antes de 0AB1. A pesar de que esta variable fue utilizada en la función, después de la llamada sigue siendo igual a 5. Esto se aplica a las 32 variables locales, por lo que puede trabajar libremente con ellas dentro de una función sin temor a perder datos.

---

```sb3
0AB3: var 0 = 10
```
[0AB3][]**0AB3** establece un nuevo valor de la variable global de CLEO. Estas variables pueden utilizarse para la comunicación de datos entre los hilos de CLEO, o entre CLEO y el main.scm. El número total de estas variables es de 100. Sus valores se guardan en la memoria de CLEO.
Estas variables pueden utilizarse en el main.scm como alternativa a las variables globales comunes.

**Parámetros:**
1. ID de la variable global. Debe estar en un rango de 0..999
2. nuevo valor de la variable. (cualquier número).

---

```sb3
0AB4: 0@ = var 0
```
[0AB4][]**0AB4** almacena en una variable el valor de la variable global CLEO. En este ejemplo, el 0@ será igual a 10 (ver 0AB3).

**Parámetros:** 
1. variable para almacenar el valor de la variable global CLEO
2. ID de la variable CLEO global. Debe estar en el rango de 0..999.

---

```sb3
0AB5: store_actor $PLAYER_ACTOR closest_vehicle_to 0@ closest_ped_to 1@
```
[0AB5][]**0AB5** almacena en las variables los controladores de un vehículo y un ped que estén más cerca del actor. Si no hay ningún vehículo o ped cerca de él, la variable propia contendrá el valor de -1.

**Parámetros:**
1. handle del actor
2. variable para almacenar el vehículo más cercano a él
3. variable para almacenar un ped que esté más cerca de él

---

```sb3
0AB6: store_target_marker_coords_to 0@ 1@ 2@ // IF and SET
```
[0AB6][]**0AB6** almacena en las variables las coordenadas del lugar marcado con el punto de destino rojo en el mapa (clic derecho en el mapa). Si el punto objetivo no existe, las variables no cambian sus valores.

**Parámetros:**
- 1,2,3 - variables para almacenar las coordenadas XYZ

---

```sb3
0AB7: get_vehicle $CAR number_of_gears_to 10@
```
[0AB7][]**0AB7** almacena en una variable el número total de marchas para el vehículo especificado. Este número es igual al parámetro TransmissionData.nNumberOfGears en el archivo handling.cfg.

**Parámetros:**
1. controlador del vehículo
2. variable para almacenar el número de marchas

---

```sb3
0AB8: get_vehicle $CAR current_gear_to 11@
```
[0AB8][]**0AB8** almacena a un número variable de la marcha actual para el vehículo especificado.

**Parámetros:**
1. controlador del vehículo
2. variable para almacenar la marcha actual

---

```sb3
0AB9: get_mp3 $hMP3 state_to 7@
```
[0AB9][]**0AB9** almacena en una variable el estado de un archivo MP3.

**Parámetros:**
1. handle de un archivo mp3 cargado ([opcode 0AAC](#0AAC))
2. variable para almacenar el estado del archivo mp3:
  - `1`: archivo en reproducción
  - `2`: archivo en pausa
  - `-1`: archivo detenido

---

```sb3
0ABA: end_custom_thread_named 'BENZIN'
```
[0ABA][]**0ABA** termina un hilo CLEO con un nombre determinado. Un hilo obtiene su nombre con el opcode 03A4. Si el hilo no fue nombrado con 03A4, el hilo obtiene su nombre por las primeras 7 letras del nombre del archivo. Por ejemplo, el hilo del archivo test.cs tendrá el nombre 'test.cs'; del archivo myscript.cs - 'myscrip'. El opcode 0ABA termina inmediatamente la ejecución de un hilo con nombre dado. Este opcode es el mismo que el 0459, pero está hecho para los scripts de CLEO.

**Parámetros:**
1. nombre del hilo a terminar.

---

```sb3
0ABD: vehicle 0@ siren_on
```
[0ABD][]**0ABD** comprueba si la sirena del vehículo `0@` está encendida. Si es así, la condición será verdadera.

**Parámetros:**
1. controlador del vehículo

---

```sb3
0ABE: vehicle 0@ engine_on
```
[0ABE][]**0ABE** comprueba si el motor del vehículo `0@` está encendido. Si es así, la condición será verdadera.

**Parámetros:**
1. controlador del vehículo

---

```sb3
0ABF: set_vehicle 0@ engine_state_to 0
```
[0ABF][]**0ABF** Activa o desactiva el motor del vehículo.

**Parámetros:**
1. controlador del vehículo 
2. nuevo estado del motor: 
  - `0`: apagado 
  - `1`: encendido

<script src="../menu.js"></script>
<script src="../../js/main.min.js"></script>